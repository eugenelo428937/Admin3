const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 6, 10);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// surface geometry
const size = 60;
const geo = new THREE.PlaneGeometry(8, 8, size, size);
geo.rotateX(-Math.PI / 2);

const mat = new THREE.MeshBasicMaterial({
  wireframe: true,
  opacity: 0.35,
  transparent: true
});

const mesh = new THREE.Mesh(geo, mat);
scene.add(mesh);

function volatilitySurface(x, y, t) {
  // stylized implied vol surface
  return Math.exp(-0.15*(x*x + y*y)) +
         0.3*Math.sin(x*2 + t) * Math.cos(y*2 + t);
}

function animate(time) {
  const t = time * 0.001;

  const pos = geo.attributes.position;

  for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i);
    const y = pos.getZ(i);
    pos.setY(i, volatilitySurface(x, y, t));
  }

  pos.needsUpdate = true;
  geo.computeVertexNormals();

  mesh.rotation.y = t * 0.15;

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

animate();
