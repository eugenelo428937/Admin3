<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Actuarial Visualizations</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0b0b12;
      color: #e0e4ec;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      height: 100vh;
    }

    /* ── Layered Canvases ──────────────────────────────────── */
    .bg-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
    }

    #canvas-vol {
      z-index: 1;
      filter: blur(1.5px);
      opacity: 0.35;
    }
    #canvas-bond {
      z-index: 2;
      filter: blur(0.8px);
      opacity: 0.3;
    }
    #canvas-surv {
      z-index: 3;
      filter: blur(0.5px);
      opacity: 0.25;
    }

    /* ── Foreground Content ────────────────────────────────── */
    #content {
      position: relative;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      padding: 40px;
      text-align: center;
    }

    #content h1 {
      font-size: 52px;
      font-weight: 700;
      line-height: 1.15;
      letter-spacing: -1px;
      margin-bottom: 16px;
      background: linear-gradient(135deg, #00f0ff, #a855f7, #f472b6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #content p {
      font-size: 18px;
      line-height: 1.6;
      color: #8892a4;
      max-width: 540px;
      margin-bottom: 36px;
    }

    .legend {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #6b7280;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 8px;
      padding: 8px 14px;
      backdrop-filter: blur(8px);
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      box-shadow: 0 0 8px currentColor;
    }

    .legend-dot.vol   { background: #00f0ff; color: #00f0ff; }
    .legend-dot.bond  { background: #a855f7; color: #a855f7; }
    .legend-dot.surv  { background: #f472b6; color: #f472b6; }
  </style>
</head>
<body>

  <!-- 3 layered canvases -->
  <canvas id="canvas-vol" class="bg-canvas"></canvas>
  <canvas id="canvas-bond" class="bg-canvas"></canvas>
  <canvas id="canvas-surv" class="bg-canvas"></canvas>

  <!-- Foreground -->
  <div id="content">
    <h1>Actuarial Education<br/>Online Store</h1>
    <p>Volatility surfaces, bond pricing curves, and survival functions — the mathematics behind actuarial science, visualised in real time.</p>
    <div class="legend">
      <div class="legend-item">
        <span class="legend-dot vol"></span>
        Implied Volatility Surface
      </div>
      <div class="legend-item">
        <span class="legend-dot bond"></span>
        Bond Price–Yield Curve
      </div>
      <div class="legend-item">
        <span class="legend-dot surv"></span>
        Survival Function
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from './three.module.min.js';

    // ── Utility: setup renderer for a canvas ─────────────────
    function createRenderer(canvasId) {
      const canvas = document.getElementById(canvasId);
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      return renderer;
    }

    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      renderers.forEach(r => r.setSize(w, h));
      cameras.forEach(c => {
        if (c.isPerspectiveCamera) {
          c.aspect = w / h;
        } else {
          const a = w / h;
          c.left = -6 * a; c.right = 6 * a;
          c.top = 3; c.bottom = -3;
        }
        c.updateProjectionMatrix();
      });
    });

    // ================================================================
    // LAYER 1: Implied Volatility Surface (wireframe mesh)
    // ================================================================
    const scene1 = new THREE.Scene();
    const camera1 = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 1000);
    camera1.position.set(0, 6, 10);
    camera1.lookAt(0, 0, 0);
    const renderer1 = createRenderer('canvas-vol');

    const volSize = 60;
    const volGeo = new THREE.PlaneGeometry(8, 8, volSize, volSize);
    volGeo.rotateX(-Math.PI / 2);

    const volMat = new THREE.MeshBasicMaterial({
      color: 0x00f0ff,
      wireframe: true,
      opacity: 0.6,
      transparent: true,
    });

    const volMesh = new THREE.Mesh(volGeo, volMat);
    scene1.add(volMesh);

    function volatilitySurface(x, y, t) {
      return Math.exp(-0.15 * (x * x + y * y)) +
             0.3 * Math.sin(x * 2 + t) * Math.cos(y * 2 + t);
    }

    // ================================================================
    // LAYER 2: Bond Price–Yield Curve (line)
    // ================================================================
    const scene2 = new THREE.Scene();
    const aspect2 = innerWidth / innerHeight;
    const camera2 = new THREE.OrthographicCamera(-6 * aspect2, 6 * aspect2, 3, -3, 0.1, 10);
    camera2.position.z = 5;
    const renderer2 = createRenderer('canvas-bond');

    const bondPts = [];
    for (let i = 0; i < 200; i++) bondPts.push(new THREE.Vector3());
    const bondGeo = new THREE.BufferGeometry().setFromPoints(bondPts);
    const bondMat = new THREE.LineBasicMaterial({
      color: 0xa855f7,
      opacity: 0.8,
      transparent: true,
    });
    const bondLine = new THREE.Line(bondGeo, bondMat);
    scene2.add(bondLine);

    function bondPrice(y, n = 10, C = 1, M = 10) {
      let p = 0;
      for (let t = 1; t <= n; t++) p += C / Math.pow(1 + y, t);
      p += M / Math.pow(1 + y, n);
      return p;
    }

    // ================================================================
    // LAYER 3: Survival Function (exponential decay curve)
    // ================================================================
    const scene3 = new THREE.Scene();
    const aspect3 = innerWidth / innerHeight;
    const camera3 = new THREE.OrthographicCamera(-6 * aspect3, 6 * aspect3, 3, -3, 0.1, 10);
    camera3.position.z = 5;
    const renderer3 = createRenderer('canvas-surv');

    const survPts = [];
    for (let i = 0; i < 200; i++) survPts.push(new THREE.Vector3());
    const survGeo = new THREE.BufferGeometry().setFromPoints(survPts);
    const survMat = new THREE.LineBasicMaterial({
      color: 0xf472b6,
      opacity: 0.8,
      transparent: true,
    });
    const survCurve = new THREE.Line(survGeo, survMat);
    scene3.add(survCurve);

    // ── Collect for resize handler ───────────────────────────
    const renderers = [renderer1, renderer2, renderer3];
    const cameras = [camera1, camera2, camera3];

    // ================================================================
    // ANIMATION LOOP — all three layers
    // ================================================================
    function animate(time) {
      const t = time * 0.001;

      // ── Layer 1: Volatility Surface ────────────────────────
      const volPos = volGeo.attributes.position;
      for (let i = 0; i < volPos.count; i++) {
        const x = volPos.getX(i);
        const y = volPos.getZ(i);
        volPos.setY(i, volatilitySurface(x, y, t));
      }
      volPos.needsUpdate = true;
      volGeo.computeVertexNormals();
      // Slow rotation < 0.2 rad/sec
      volMesh.rotation.y = t * 0.12;

      renderer1.render(scene1, camera1);

      // ── Layer 2: Bond Price Curve ──────────────────────────
      const bondArr = bondGeo.attributes.position.array;
      for (let i = 0; i < 200; i++) {
        const y = (i / 200) * 0.15 + 0.01;
        const shift = 0.01 * Math.sin(t * 0.7);
        const price = bondPrice(y + shift);
        bondArr[i * 3]     = (i / 200) * 10 - 5;
        bondArr[i * 3 + 1] = price * 0.2 - 2;
        bondArr[i * 3 + 2] = 0;
      }
      bondGeo.attributes.position.needsUpdate = true;
      renderer2.render(scene2, camera2);

      // ── Layer 3: Survival Function ─────────────────────────
      const lambda = 0.4 + 0.2 * Math.sin(t * 0.6);
      const survArr = survGeo.attributes.position.array;
      for (let i = 0; i < 200; i++) {
        const x = (i / 200) * 10;
        const s = Math.exp(-lambda * x);
        survArr[i * 3]     = x - 5;
        survArr[i * 3 + 1] = s * 2 - 1;
        survArr[i * 3 + 2] = 0;
      }
      survGeo.attributes.position.needsUpdate = true;
      renderer3.render(scene3, camera3);

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  </script>
</body>
</html>
